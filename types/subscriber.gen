package types

import (
	"time"
)

//genify:subr=applications,application,service,instance

func (s *Subr) Sub(full bool, depth uint8, maxStale time.Duration, onlyChanges bool) Subscription {
	return s.Subscribe(full, depth, maxStale, onlyChanges)
}

func (s *Subr) GetStatus(depth uint8) SubrStatus {
	sub := s.Subscribe(true, depth, 0, false)
	defer sub.Close()
	return <-sub.C
}

type subrBroker struct {
	notifier       chan SubrStatus
	newClients     chan *SubrSubscription
	closingClients chan chan SubrStatus
	clients        map[chan SubrStatus]*SubrSubscription
}

type SubrSubscription struct {
	baseSubscription
	C       chan SubrStatus
	close   chan chan SubrStatus
}

func (s *SubrSubscription) Close() {
	s.close <- s.C
}

func (s *SubrSubscription) Next() interface{} {
	return <-s.C
}

func (s *Subr) Subscribe(full bool, depth uint8, maxStale time.Duration, onlyChanges bool) *SubrSubscription {
	if s.broker == nil {
		s.brokerLock.Lock()
		if s.broker == nil {
			s.broker = newSubrBroker()
		}
		s.brokerLock.Unlock()
	}
	r := &SubrSubscription{
		C:     make(chan SubrStatus),
		close: s.broker.closingClients,
		baseSubscription: baseSubscription{
			opts:        newBrokerOptions(full, depth).maxDepth(1),
			maxStale:    maxStale,
			onlyChanges: onlyChanges,
		},
	}
	r.setMaxStale()
	s.broker.newClients <- r
	return r
}

//genify:subr=applications,application,service

func newSubrBroker() *subrBroker {
	b := &subrBroker{
		notifier:       make(chan SubrStatus),
		newClients:     make(chan *SubrSubscription),
		closingClients: make(chan chan SubrStatus),
		clients:        make(map[chan SubrStatus]*SubrSubscription),
	}
	go func() {
		var ss [4]SubrStatus
		var updated [4]bool
		f := newBrokerOptions(true, 1)
		i := newBrokerOptions(false, 1)
		for {
			select {
			case c := <-b.newClients:
				b.clients[c.C] = c
				if !updated[f] {
					continue
				}
				r := newBrokerOptions(true, c.opts.depth())
				if !updated[r] {
					ss[r].update(r, &ss[i], &ss[f])
					updated[r] = true
				}
				c.lastUpdate = ss[r].TimeStamp
				go func(c chan SubrStatus, ss SubrStatus) {
					c <- ss
				}(c.C, ss[r])
			case c := <-b.closingClients:
				delete(b.clients, c)
			case ss[i] = <-b.notifier:
				var changed [4]bool
				updated = [4]bool{}
				ss[f].updateFrom(&ss[i])
				ss[f].recalculate()
				changed[f] = true
				updated[f] = true
				ss[i].copySummaryFrom(&ss[f])
				changed[i] = true
				updated[i] = true
				for c, o := range b.clients {
					if !updated[o.opts] {
						changed[o.opts] = ss[o.opts].update(o.opts, &ss[i], &ss[f])
						updated[o.opts] = true
					}
					if changed[o.opts] || ss[o.opts].TimeStamp.Sub(o.lastUpdate) >= o.maxStale {
						o.lastUpdate = ss[o.opts].TimeStamp
						go func(c chan SubrStatus, ss SubrStatus) {
							c <- ss
						}(c, ss[o.opts])
					}
				}
			}
		}
	}()
	return b
}

func (ss *SubrStatus) update(o brokerOptions, ssi, ssf *SubrStatus) bool {
	changes := ss.copySummaryFrom(ssf)

	ssu := ssi
	if o.full() {
		ssu = ssf
	}

	if !ss.contains(ssu, o.depth()) {
		ss.updateFrom(ssu)
		changes = true
	}

	ss.filter(o.depth())
	return changes
}

// vim: filetype=go
